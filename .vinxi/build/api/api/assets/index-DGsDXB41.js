import{AsyncLocalStorage as R}from"node:async_hooks";import{H3Event as d,getRequestWebStream as _,getRequestURL as v,eventHandler as x}from"h3";function S(t={}){let e,r=!1;const o=n=>{if(e&&e!==n)throw new Error("Context conflict")};let s;if(t.asyncContext){const n=t.AsyncLocalStorage||globalThis.AsyncLocalStorage;n?s=new n:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const a=()=>{if(s){const n=s.getStore();if(n!==void 0)return n}return e};return{use:()=>{const n=a();if(n===void 0)throw new Error("Context is not available");return n},tryUse:()=>a(),set:(n,i)=>{i||o(n),e=n,r=!0},unset:()=>{e=void 0,r=!1},call:(n,i)=>{o(n),e=n;try{return s?s.run(n,i):i()}finally{r||(e=void 0)}},async callAsync(n,i){e=n;const l=()=>{e=n},u=()=>e===n?l:void 0;P.add(u);try{const f=s?s.run(n,i):i();return r||(e=void 0),await f}finally{P.delete(u)}}}}function T(t={}){const e={};return{get(r,o={}){return e[r]||(e[r]=S({...t,...o})),e[r]}}}const h=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},p="__unctx__",A=h[p]||(h[p]=T()),E=(t,e={})=>A.get(t,e),g="__unctx_async_handlers__",P=h[g]||(h[g]=new Set);function H(t){let e;const r=b(t),o={duplex:"half",method:t.method,headers:t.headers};return t.node.req.body instanceof ArrayBuffer?new Request(r,{...o,body:t.node.req.body}):new Request(r,{...o,get body(){return e||(e=L(t),e)}})}function C(t){return t.web??(t.web={request:H(t),url:b(t)}),t.web.request}function I(){return q()}const m=Symbol("$HTTPEvent");function U(t){return typeof t=="object"&&(t instanceof d||t?.[m]instanceof d||t?.__is_event__===!0)}function w(t){return function(...e){var r;const o=e[0];if(U(o))e[0]=o instanceof d||o.__is_event__?o:o[m];else{if(!((r=globalThis.app.config.server.experimental)!=null&&r.asyncContext))throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");e.unshift(I())}return t(...e)}}const b=w(v),L=w(_);function $(){var t;return E("nitro-app",{asyncContext:!!((t=globalThis.app.config.server.experimental)!=null&&t.asyncContext),AsyncLocalStorage:R})}function q(){const t=$().use().event;if(!t)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");return t}const W=[{path:"/__root",filePath:"/Users/leonardo/PersProgetti/start-basic-alpha/src/routes/__root.tsx"},{path:"/calendar",filePath:"/Users/leonardo/PersProgetti/start-basic-alpha/src/routes/calendar.tsx"},{path:"/",filePath:"/Users/leonardo/PersProgetti/start-basic-alpha/src/routes/index.tsx"},{path:"/profile",filePath:"/Users/leonardo/PersProgetti/start-basic-alpha/src/routes/profile.tsx"},{path:"/sign-in",filePath:"/Users/leonardo/PersProgetti/start-basic-alpha/src/routes/sign-in.tsx"},{path:"/sign-up",filePath:"/Users/leonardo/PersProgetti/start-basic-alpha/src/routes/sign-up.tsx"},{path:"/api/auth/*splat",filePath:"/Users/leonardo/PersProgetti/start-basic-alpha/src/routes/api/auth.$.ts",$APIRoute:{src:"src/routes/api/auth.$.ts?pick=APIRoute",build:()=>import("../auth._.js"),import:()=>import("../auth._.js")}}],B=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function D(t){return x(async e=>{const r=C(e);return await t({request:r})})}const K=t=>e=>({path:t,methods:e});function N(t,e){const r=t.pathname.split("/").filter(Boolean),o=e.sort((s,a)=>{const n=s.routePath.split("/").filter(Boolean);return a.routePath.split("/").filter(Boolean).length-n.length}).filter(s=>{const a=s.routePath.split("/").filter(Boolean);return r.length>=a.length});for(const s of o){const a=s.routePath.split("/").filter(Boolean),n={};let i=!0;for(let l=0;l<a.length;l++){const u=a[l],f=r[l];if(u.startsWith("$"))if(u==="$"){const c=r.slice(l).join("/");if(c!=="")n["*"]=c,n._splat=c;else{i=!1;break}}else{const c=u.slice(1);n[c]=f}else if(u!==f){i=!1;break}}if(i)return{routePath:s.routePath,params:n,payload:s.payload}}}const y=W.filter(t=>t.$APIRoute);function F(t){const e=[];return t.forEach(r=>{const s=r.path.split("/").filter(Boolean).map(a=>a==="*splat"?"$":a.startsWith(":$")&&a.endsWith("?")?a.slice(1,-1):a).join("/");e.push({routePath:`/${s}`,payload:r})}),e}const k=async({request:t})=>{if(!y.length)return new Response("No routes found",{status:404});if(!B.includes(t.method))return new Response("Method not allowed",{status:405});const e=F(y),r=new URL(t.url,"http://localhost:3000"),o=N(r,e);if(!o)return new Response("Not found",{status:404});let s;try{s=await o.payload.$APIRoute.import().then(i=>i.APIRoute)}catch(i){return console.error("Error importing route file:",i),new Response("Internal server error",{status:500})}if(!s)return new Response("Internal server error",{status:500});const a=t.method,n=s.methods[a];return n?await n({request:t,params:o.params}):new Response("Method not allowed",{status:405})};export{K as a,D as c,k as d};

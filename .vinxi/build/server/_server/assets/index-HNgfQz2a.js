import{i as v,a as p}from"./server-De-CGB3V.js";import{isRedirect as C,isNotFound as b}from"@tanstack/router-core";function g(e){if(Array.isArray(e))return e.flatMap(u=>g(u));if(typeof e!="string")return[];const n=[];let t=0,r,i,s,o,a;const c=()=>{for(;t<e.length&&/\s/.test(e.charAt(t));)t+=1;return t<e.length},l=()=>(i=e.charAt(t),i!=="="&&i!==";"&&i!==",");for(;t<e.length;){for(r=t,a=!1;c();)if(i=e.charAt(t),i===","){for(s=t,t+=1,c(),o=t;t<e.length&&l();)t+=1;t<e.length&&e.charAt(t)==="="?(a=!0,t=o,n.push(e.slice(r,s)),r=t):t=s+1}else t+=1;(!a||t>=e.length)&&n.push(e.slice(r,e.length))}return n}function F(e){return e instanceof Headers?new Headers(e):Array.isArray(e)?new Headers(e):typeof e=="object"?new Headers(e):new Headers}function j(...e){return e.reduce((n,t)=>{const r=F(t);for(const[i,s]of r.entries())i==="set-cookie"?g(s).forEach(a=>n.append("set-cookie",a)):n.set(i,s);return n},new Headers)}const A=[];function w(e,n){const t=n||e||{};return typeof t.method>"u"&&(t.method="GET"),{options:t,middleware:r=>w(void 0,Object.assign(t,{middleware:r})),validator:r=>w(void 0,Object.assign(t,{validator:r})),type:r=>w(void 0,Object.assign(t,{type:r})),handler:(...r)=>{const[i,s]=r;Object.assign(t,{...i,extractedFn:i,serverFn:s});const o=[...t.middleware||[],I(t)];return Object.assign(async a=>m(o,"client",{...i,...t,data:a?.data,headers:a?.headers,signal:a?.signal,context:{}}).then(c=>{if(t.response==="full")return c;if(c.error)throw c.error;return c.result}),{...i,__executeServer:async(a,c)=>{const l=a instanceof FormData?O(a):a;l.type=typeof t.type=="function"?t.type(l):t.type;const u={...i,...l,signal:c},h=()=>m(o,"server",u).then(d=>({result:d.result,error:d.error,context:d.sendContext}));if(u.type==="static"){let d;if(f?.getItem&&(d=await f.getItem(u)),d||(d=await h().then(y=>({ctx:y,error:null})).catch(y=>({ctx:void 0,error:y})),f?.setItem&&await f.setItem(u,d)),v(d),d.error)throw d.error;return d.ctx}return h()}})}}}async function m(e,n,t){const r=E([...A,...e]),i=async s=>{const o=r.shift();if(!o)return s;o.options.validator&&(n!=="client"||o.options.validateClient)&&(s.data=await T(o.options.validator,s.data));const a=n==="client"?o.options.client:o.options.server;return a?H(a,s,async c=>i(c).catch(l=>{if(C(l)||b(l))return{...c,error:l};throw l})):i(s)};return i({...t,headers:t.headers||{},sendContext:t.sendContext||{},context:t.context||{}})}let f;function _(e){const n=f;return f=typeof e=="function"?e():e,()=>{f=n}}async function S(e){const n=new TextEncoder().encode(e),t=await crypto.subtle.digest("SHA-1",n);return Array.from(new Uint8Array(t)).map(s=>s.toString(16).padStart(2,"0")).join("")}_(()=>{const e=async(r,i)=>`/__tsr/staticServerFnCache/${await S(`${r.functionId}__${i}`)}.json`,n=r=>JSON.stringify(r??"",(o,a)=>a&&typeof a=="object"&&!Array.isArray(a)?Object.keys(a).sort().reduce((c,l)=>(c[l]=a[l],c),{}):a).replace(/[/\\?%*:|"<>]/g,"-").replace(/\s+/g,"_"),t=typeof document<"u"?new Map:null;return{getItem:async r=>{if(typeof document>"u"){const i=n(r.data),s=await e(r,i),o="/Users/leonardo/PersProgetti/start-basic-alpha/dist",{promises:a}=await import("node:fs"),l=(await import("node:path")).join(o,s),[u,h]=await a.readFile(l,"utf-8").then(d=>[p.parse(d),null]).catch(d=>[null,d]);if(h&&h.code!=="ENOENT")throw h;return u}},setItem:async(r,i)=>{const{promises:s}=await import("node:fs"),o=await import("node:path"),a=n(r.data),c=await e(r,a),u=o.join("/Users/leonardo/PersProgetti/start-basic-alpha/dist",c);await s.mkdir(o.dirname(u),{recursive:!0}),await s.writeFile(u,p.stringify(i))},fetchItem:async r=>{const i=n(r.data),s=await e(r,i);let o=t?.get(s);return o||(o=await fetch(s,{method:"GET"}).then(a=>a.text()).then(a=>p.parse(a)),t?.set(s,o)),o}}});function O(e){const n=e.get("__TSR_CONTEXT");if(e.delete("__TSR_CONTEXT"),typeof n!="string")return{context:{},data:e};try{return{context:p.parse(n),data:e}}catch{return{data:e}}}function E(e){const n=new Set,t=[],r=i=>{i.forEach(s=>{s.options.middleware&&r(s.options.middleware),n.has(s)||(n.add(s),t.push(s))})};return r(e),t}const H=async(e,n,t)=>e({...n,next:async(r={})=>t({...n,...r,context:{...n.context,...r.context},sendContext:{...n.sendContext,...r.sendContext??{}},headers:j(n.headers,r.headers),result:r.result!==void 0?r.result:n.response==="raw"?r:n.result,error:r.error??n.error})});function T(e,n){if(e==null)return{};if("~standard"in e){const t=e["~standard"].validate(n);if(t instanceof Promise)throw new Error("Async validation not supported");if(t.issues)throw new Error(JSON.stringify(t.issues,void 0,2));return t.value}if("parse"in e)return e.parse(n);if(typeof e=="function")return e(n);throw new Error("Invalid validator type!")}function I(e){return{_types:void 0,options:{validator:e.validator,validateClient:e.validateClient,client:async({next:n,sendContext:t,...r})=>{var i;const s={...r,context:t,type:typeof r.type=="function"?r.type(r):r.type};if(r.type==="static"&&typeof document<"u"){v(f);const a=await f.fetchItem(s);if(a){if(a.error)throw a.error;return n(a.ctx)}`${s.functionId}${JSON.stringify(s.data)}`}const o=await((i=e.extractedFn)==null?void 0:i.call(e,s));return n(o)},server:async({next:n,...t})=>{var r;const i=await((r=e.serverFn)==null?void 0:r.call(e,t));return n({...t,result:i})}}}}function x(e){return e.replace(/^\/|\/$/g,"")}const $=(e,n,t)=>{v(t);const r=`/${x(n)}/${e}`;return Object.assign(t,{url:r,functionId:e})};export{w as a,$ as c,j as m};
